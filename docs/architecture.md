# Architecture & Design Patterns

This document describes the core components, database design, and architectural patterns used in this project.

## Core Components

### Database Layer

**Schema Definition** (`lib/schema.ts`)
- Drizzle ORM schema for type-safe operations
- Auto-generates TypeScript types (`Song`, `NewSong`)
- Primary tables:
  - `songs` - iTunes library metadata
  - `spotifySearchCache` - Search result cache (30-day TTL)
- Indexes on frequently queried columns (artist, album, album_artist)

**Database Connection** (`lib/db.ts`)
- Singleton pattern for single connection per process
- Automatic environment detection:
  - **Local dev**: SQLite file via `file:./database.db`
  - **Production/CI**: Turso via HTTPS URL
- Uses `@libsql/client` for unified interface
- Connection configured via environment variables:
  - `TURSO_DATABASE_URL` - Database URL
  - `TURSO_AUTH_TOKEN` - Auth token

**Migrations** (`drizzle/migrations/`)
- Version-controlled SQL migration files
- Tracked in `__drizzle_migrations` table
- Idempotent (safe to run multiple times)
- Generated via: `npm run db:generate`
- Applied via: `npm run db:migrate`

### Spotify Integration

**Client** (`lib/spotify.ts`)
- Modern SDK: `@spotify/web-api-ts-sdk`
- Client credentials flow for authentication
- Main function: `searchSpotifyTracks()`
  - Parameters: artist, album, track
  - Returns: Array of Spotify track results
- Token management handled automatically by SDK

**Server Actions** (`lib/spotify-actions.ts`)
- Next.js Server Actions for database operations
- Key actions:
  - `getNextUnmatchedSong()` - Fetch first song without spotify_id
  - `getSongsByArtist()` - Get all songs by artist (sorted by album)
  - `searchSpotifyByArtistAlbum()` - Search Spotify with caching
  - `searchSpotifyForSong()` - Smart search with fallback strategies
  - `saveSongMatch()` - Save spotify_id for matched song
  - `clearSongMatch()` - Remove spotify_id from song
  - `getRandomUnmatchedSong()` - Random unmatched song for review

**Search Strategy**
1. **Primary search**: Artist + Track name
2. **Fallback search**: Track name only (if primary < 50% similarity)
3. **Similarity scoring**: Enhanced algorithm with multiple factors
4. **Caching**: 30-day TTL to reduce API calls

### Spotify Matcher UI

**Page** (`app/spotify-matcher/page.tsx`)
- Interactive UI for matching iTunes → Spotify
- Features:
  - Auto-match mode with configurable threshold
  - Manual review with similarity scoring
  - Artist view (all albums by artist)
  - AI metadata fixing integration
  - Search result previews
  - One-click matching

**State Management** (`app/spotify-matcher/state/reducer.ts`)
- React reducer for complex state
- Actions: load songs, update matches, apply AI fixes, etc.
- Extracted from page for testability

**Components** (`app/spotify-matcher/`)
- `ReviewCard.tsx` - Song review card with match options
- `AISuggestion.tsx` - AI metadata fix suggestions
- `SongTableRow.tsx` - Table row for artist view

### AI Integration

**Metadata Fixer** (`lib/ai-metadata-fixer.ts`)
- Groq SDK with LLaMA 3.3 70B model
- Fixes common metadata issues:
  - Whitespace, featured artists, special characters
- In-memory caching (Map)
- Zod schema validation for type-safe responses
- Graceful error handling

See [AI Features](ai-features.md) for detailed documentation.

## Database Schema

### Songs Table

```sql
CREATE TABLE songs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT NOT NULL,
  artist TEXT NOT NULL,
  album TEXT,
  album_artist TEXT,
  filename TEXT,
  spotify_id TEXT,
  UNIQUE(filename)
);

CREATE INDEX idx_artist_album ON songs(artist, album, album_artist);
```

**TypeScript Types** (auto-generated by Drizzle):
```typescript
type Song = {
  id: number
  title: string
  artist: string
  album: string | null
  album_artist: string | null
  filename: string | null
  spotify_id: string | null
}

type NewSong = Omit<Song, 'id'>
```

### Spotify Search Cache Table

```sql
CREATE TABLE spotify_search_cache (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  query_hash TEXT NOT NULL UNIQUE,
  results TEXT NOT NULL,  -- JSON array
  created_at INTEGER NOT NULL
);

CREATE INDEX idx_created_at ON spotify_search_cache(created_at);
```

**Cache Strategy:**
- Hash search parameters (artist, album, track)
- Store JSON results
- 30-day TTL (configurable)
- Automatic cleanup of expired entries

## Design Patterns

### Singleton Pattern

**Database Connection** (`lib/db.ts`):
```typescript
let _db: ReturnType<typeof drizzle> | null = null

export function getDb() {
  if (!_db) {
    const client = createClient({
      url: process.env.TURSO_DATABASE_URL || 'file:./database.db',
      authToken: process.env.TURSO_AUTH_TOKEN
    })
    _db = drizzle(client)
  }
  return _db
}
```

Ensures one database connection per process.

### Factory Pattern

**Test Fixtures** (`lib/test-helpers/fixtures.ts`):
```typescript
export function createMockSong(overrides: Partial<Song> = {}): Song {
  return {
    id: 1,
    title: 'Test Song',
    artist: 'Test Artist',
    album: 'Test Album',
    album_artist: null,
    filename: 'test.mp3',
    spotify_id: null,
    ...overrides
  }
}
```

Consistent test data with overridable defaults.

### Strategy Pattern

**Similarity Scoring** (`lib/enhanced-similarity.ts`):
Multiple scoring strategies combined:
1. Artist name matching
2. Track title matching
3. Album matching
4. Artist-as-album detection
5. Cover/remix detection

Each strategy contributes to final confidence score.

### Reducer Pattern

**Page State** (`app/spotify-matcher/state/reducer.ts`):
```typescript
type Action =
  | { type: 'LOAD_SONGS'; payload: Song[] }
  | { type: 'UPDATE_MATCH'; payload: { songId: number; spotifyId: string } }
  | { type: 'UPDATE_SONG_METADATA'; payload: Song }
  // ... more actions

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'LOAD_SONGS':
      return { ...state, songs: action.payload }
    // ... more cases
  }
}
```

Centralized state management for complex UI.

### Server Action Pattern

All database mutations through Next.js Server Actions:
- Type-safe
- Automatic serialization
- CSRF protection
- Easy error handling

Example:
```typescript
'use server'

export async function saveSongMatch(
  songId: number,
  spotifyId: string
): Promise<{ success: true } | { success: false; error: string }> {
  try {
    const db = getDb()
    await db.update(songs).set({ spotify_id: spotifyId }).where(eq(songs.id, songId))
    return { success: true }
  } catch (error) {
    return { success: false, error: 'Failed to save match' }
  }
}
```

## Module Organization

### Recommended File Size Targets

- **Page components**: ~400 lines or less
- **Utility modules**: ~100 lines or less
- **React components**: ~150 lines or less
- **Test files**: Unlimited (comprehensive coverage preferred)

### Module Structure

```
feature/
├── page.tsx                 # Main page (orchestrator)
├── state/
│   ├── reducer.ts          # State management
│   └── reducer.test.ts     # Reducer tests
├── components/
│   ├── ComponentA.tsx      # UI component
│   └── ComponentB.tsx      # UI component
└── hooks/
    ├── useFeature.ts       # Custom hook
    └── useFeature.test.ts  # Hook tests
```

### Code Organization Principles

Based on `app/spotify-matcher/page.tsx` refactoring:

1. **Extract utility functions** - Pure functions go to `lib/` with tests
2. **Extract state management** - Reducers go to `state/` subdirectory with tests
3. **Extract components** - Large JSX blocks (>30 lines) become separate components
4. **Avoid inline objects** - Use factory functions for test fixtures
5. **Single responsibility** - Files should have one clear purpose

## Data Flow

### Song Matching Flow

```
1. User clicks "Load Next Song"
   ↓
2. Server Action: getNextUnmatchedSong()
   ↓
3. Query database for song without spotify_id
   ↓
4. Return song to client
   ↓
5. Client auto-searches Spotify
   ↓
6. Server Action: searchSpotifyForSong()
   ↓
7. Check cache for existing results
   ↓
8. If not cached: Call Spotify API
   ↓
9. Calculate similarity scores
   ↓
10. Cache results (30-day TTL)
   ↓
11. Return top matches to client
   ↓
12. Client displays matches with confidence
   ↓
13. User selects match
   ↓
14. Server Action: saveSongMatch()
   ↓
15. Update database with spotify_id
```

### AI Metadata Fix Flow

```
1. User clicks "AI Fix"
   ↓
2. Server Action: getAISuggestionForSong()
   ↓
3. Check in-memory cache
   ↓
4. If not cached: Call Groq API
   ↓
5. Parse and validate response (Zod)
   ↓
6. Cache suggestion
   ↓
7. Return suggestion to client
   ↓
8. Client displays diff and confidence
   ↓
9. User clicks "Apply Fix"
   ↓
10. Server Action: applyAIFixToSong()
   ↓
11. Update database with corrected metadata
   ↓
12. Clear spotify_id (will need re-matching)
   ↓
13. Client re-searches Spotify automatically
```

## Performance Considerations

### Database Queries

**Optimizations:**
- Indexes on (artist, album, album_artist)
- Cursor-based pagination for large result sets
- Limit results to prevent loading entire table

**Avoiding N+1 queries:**
- Batch operations when possible
- Use joins instead of multiple queries
- Server-side aggregation

### Caching Strategy

**Spotify Search Cache:**
- 30-day TTL (configurable in `lib/spotify-cache.ts`)
- Hash-based keys for fast lookup
- Automatic cleanup of expired entries
- Database-backed for persistence

**AI Suggestions:**
- In-memory cache (Map)
- Keyed by song ID
- Resets on server restart
- Future: Migrate to persistent cache

### API Rate Limiting

**Spotify API:**
- Client credentials flow (app-level tokens)
- No explicit rate limiting implemented yet
- Future: Retry logic with exponential backoff

**Groq API:**
- Free tier: 30 requests/minute
- In-memory caching reduces calls
- Graceful degradation on errors

## Security

### Environment Variables

**Required:**
- `SPOTIFY_CLIENT_ID` - Public
- `SPOTIFY_CLIENT_SECRET` - Private
- `TURSO_DATABASE_URL` - Private (production)
- `TURSO_AUTH_TOKEN` - Private (production)

**Optional:**
- `GOOGLE_CLIENT_ID` - Public
- `GOOGLE_CLIENT_SECRET` - Private
- `AUTH_SECRET` - Private (NextAuth)
- `ALLOWED_EMAIL` - Public
- `GROQ_API_KEY` - Private

**Never commit:**
- `.env.local` (gitignored)
- `database.db` (gitignored)
- Real API credentials

### Authentication

See [OAuth Setup](oauth.md) for Google OAuth configuration.

**Middleware** (`middleware.ts`):
- Protects all routes except auth pages
- Single email whitelist
- JWT session storage

### Input Validation

**Server Actions:**
- Validate all input parameters
- Sanitize database queries (Drizzle handles this)
- Return type-safe results

**API Calls:**
- Trim whitespace from search parameters
- Future: Escape special characters for Spotify
- Rate limiting (planned)

## Error Handling

### Graceful Degradation

**AI Metadata Fixer:**
- Returns `null` on errors
- Logs errors for debugging
- UI continues to work without AI

**Spotify Search:**
- Returns empty array on errors
- Logs errors with context
- User can retry manually

### Logging Strategy

**Console logging:**
```typescript
console.error('Error searching Spotify', {
  artist,
  track,
  error: JSON.stringify(err)
})
```

**Future enhancements:**
- Structured logging utility
- Error tracking service (Sentry)
- User-friendly error messages

## Testing Architecture

See [Testing Guide](testing.md) for comprehensive documentation.

**Test organization:**
- Unit tests colocated with source (`*.test.ts`)
- Integration tests in `test/` directory
- E2E tests in `e2e/` directory
- Shared fixtures in `lib/test-helpers/`

**Polly.js integration:**
- Records real Spotify API responses
- Enables offline testing
- Committed recordings for CI

## Future Architectural Improvements

### 1. Persistent AI Cache

Migrate from in-memory to database:
```sql
CREATE TABLE ai_metadata_suggestions (
  song_id INTEGER PRIMARY KEY,
  suggestion TEXT NOT NULL,  -- JSON
  created_at INTEGER NOT NULL
);
```

### 2. Event Sourcing for Matches

Track all matching decisions:
```sql
CREATE TABLE match_events (
  id INTEGER PRIMARY KEY,
  song_id INTEGER NOT NULL,
  spotify_id TEXT,
  confidence REAL,
  method TEXT,  -- 'manual', 'auto', 'ai'
  created_at INTEGER NOT NULL
);
```

Enables:
- Undo functionality
- Match history
- Analytics

### 3. Background Job Queue

For batch operations:
- Auto-matching large libraries
- Bulk AI metadata fixes
- Cache warming

### 4. WebSocket for Real-time Updates

Auto-match progress updates:
- Show current song being processed
- Progress bar for batch operations
- Error notifications

## Related Documentation

- [Testing Guide](testing.md) - Testing strategy and Polly.js
- [AI Features](ai-features.md) - AI metadata fixer
- [Deployment Guide](deployment.md) - Production architecture
- [OAuth Setup](oauth.md) - Authentication flow
